:PROPERTIES:
:ID:       6cacb474-009b-491c-a8fb-cb8b1121e47d
:arch_package: emacs-nativecomp
:version: latest
:END:
#+TITLE: MineMacs
#+auto_tangle: t
#+property: header-args :eval never-export :mkdirp yes :results silent

* The Basics
** Lexical Binding
#+begin_src elisp
  ;;; README.el --- Global settings -*- lexical-binding: t; -*-
#+end_src

** TODO General
Some sane defaults copied from crafted-emacs. 

#+begin_src elisp 
  ;; Revert Dired and other buffers
  (customize-set-variable 'global-auto-revert-non-file-buffers t)

  ;; Revert buffers when the underlying file has changed
  (global-auto-revert-mode 1)

  ;; Typed text replaces the selection if the selection is active,
  ;; pressing delete or backspace deletes the selection.
  (delete-selection-mode)

  ;; Use spaces instead of tabs
  (setq-default indent-tabs-mode nil)

  (setq use-short-answers t)

  ;; Turn on recentf mode
  (add-hook 'after-init-hook #'recentf-mode)
  (setq recentf-save-file
        (expand-file-name "recentf" (expand-config-directory "cache/")))

  ;; Do not save duplicates in kill-ring
  (customize-set-variable 'kill-do-not-save-duplicates t)

  ;; Make scrolling less stuttered
  (setq auto-window-vscroll nil)
  (customize-set-variable 'fast-but-imprecise-scrolling t)
  (customize-set-variable 'scroll-conservatively 101)
  (customize-set-variable 'scroll-margin 0)
  (customize-set-variable 'scroll-preserve-screen-position t)

  ;; Better support for files with long lines
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq-default bidi-inhibit-bpa t)
  (global-so-long-mode 1)

  ;; Make shebang (#!) file executable when saved
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)

  ;; Enable savehist-mode for command history
  (savehist-mode 1)


  ;; To use the system clipboard for copy/paste
  (setq select-enable-clipboard t)
  (setq select-enable-primary t)
#+end_src

** Default UI
#+begin_src elisp
  ;; Remove some unneeded UI elements
  (setq inhibit-startup-message t)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(mouse-color . "white") default-frame-alist)
  (tool-bar-mode   -1)
  (scroll-bar-mode -1)
#+end_src

** Font
#+begin_src elisp
  (add-hook 'emacs-startup-hook
    (lambda ()
      (custom-set-faces
       `(default ((t (:font "JetBrainsMono Nerd Font,DejaVu Sans Mono,Courier New"))))
       `(fixed-pitch ((t (:inherit (default)))))
       `(fixed-pitch-serif ((t (:inherit (default)))))
       `(variable-pitch ((t (:font "Fira Sans,Arial,Helvetica")))))))
#+end_src

** General Keybindings
*** COMMENT EVIL Mode
Migrating to meow-mode. Leaving this until it's done.

#+begin_src elisp

  ;; (use-package evil
  ;;   :ensure t
  ;;   :init
  ;;   (customize-set-variable 'evil-want-integration t)
  ;;   (customize-set-variable 'evil-want-keybinding nil)
  ;;   (customize-set-variable 'evil-want-C-i-jump nil)
  ;;   (customize-set-variable 'evil-respect-visual-line-mode t)
  ;;   (customize-set-variable 'evil-undo-system 'undo-redo)
  ;;   ;; TODO: Do I want these?
  ;;   ;; (customize-set-variable 'evil-want-C-i-jump t)
  ;;   ;; (customize-set-variable 'evil-want-Y-yank-to-eol t)
  ;;   ;; (customize-set-variable 'evil-want-fine-undo t))
  ;;   :config
  ;;   (evil-mode 1)
  ;;   (setq evil-auto-indent t)
  ;;   ;; Make evil search more like vim
  ;;   (evil-select-search-module 'evil-search-module 'evil-search)
  ;;   ;; Make C-g revert to normal state
  ;;   (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  ;;   ;; Rebind `universal-argument' to 'C-M-u' since 'C-u' now scrolls the buffer
  ;;   (global-set-key (kbd "C-M-u") 'universal-argument)
  ;;   ;; Use visual line motions even ouside of visual-line-mode buffers
  ;;   (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  ;;   (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  ;;   ;; Make sure some modes start in Emacs state
  ;;   (dolist (mode '(custom-mode
  ;;                   eshell-mode
  ;;                   term-mode))
  ;;     (add-to-list 'evil-emacs-state-modes mode)))

  ;; (use-package evil-nerd-commenter
  ;;   :requires evil
  ;;   :ensure t
  ;;   :config
  ;;   ;; Enables Evil Nerd Commenter
  ;;   (evilnc-default-hotkeys))

  ;; (use-package evil-collection
  ;;   :requires evil
  ;;   :ensure t
  ;;   :config
  ;;   (evil-collection-init))
#+end_src

*** Meow-Mode
Modal editing for default emacs keybindings.

#+begin_src elisp
  (use-package meow
    :custom
    (meow-use-clipboard t)
    :config 
    ;; NOTE: default QWERTY setup (found here: https://github.com/meow-edit/meow/blob/master/KEYBINDING_QWERTY.org)
    (defun meow-setup ()
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
      ;; NOTE: meow-motion-define-key, as shown in example, didn't exist. meow-motion-overwrite-define-key appears to be its replacement
      (meow-motion-overwrite-define-key
       '("j" . meow-next)
       '("k" . meow-prev)
       '("<escape>" . ignore))
      (meow-leader-define-key
       ;; Use SPC (0-9) for digit arguments.
       '("1" . meow-digit-argument)
       '("2" . meow-digit-argument)
       '("3" . meow-digit-argument)
       '("4" . meow-digit-argument)
       '("5" . meow-digit-argument)
       '("6" . meow-digit-argument)
       '("7" . meow-digit-argument)
       '("8" . meow-digit-argument)
       '("9" . meow-digit-argument)
       '("0" . meow-digit-argument)
       '("/" . meow-keypad-describe-key)
       '("?" . meow-cheatsheet))
      (meow-normal-define-key
       '("0" . meow-expand-0)
       '("9" . meow-expand-9)
       '("8" . meow-expand-8)
       '("7" . meow-expand-7)
       '("6" . meow-expand-6)
       '("5" . meow-expand-5)
       '("4" . meow-expand-4)
       '("3" . meow-expand-3)
       '("2" . meow-expand-2)
       '("1" . meow-expand-1)
       '("-" . negative-argument)
       '(";" . meow-reverse)
       '("," . meow-inner-of-thing)
       '("." . meow-bounds-of-thing)
       '("[" . meow-beginning-of-thing)
       '("]" . meow-end-of-thing)
       '("a" . meow-append)
       '("A" . meow-open-below)
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("c" . meow-change)
       '("d" . meow-delete)
       '("D" . meow-backward-delete)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("f" . meow-find)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("i" . meow-insert)
       '("I" . meow-open-above)
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '("m" . meow-join)
       '("n" . meow-search)
       '("o" . meow-block)
       '("O" . meow-to-block)
       '("p" . meow-yank)
       '("q" . meow-quit)
       '("Q" . meow-goto-line)
       '("r" . meow-replace)
       '("R" . meow-swap-grab)
       '("s" . meow-kill)
       '("t" . meow-till)
       '("u" . meow-undo)
       '("U" . meow-undo-in-selection)
       '("v" . meow-visit)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("x" . meow-line)
       '("X" . meow-goto-line)
       '("y" . meow-save)
       '("Y" . meow-sync-grab)
       '("z" . meow-pop-selection)
       '("'" . repeat)
       '("<escape>" . ignore)))

    (meow-setup)
    (add-to-list 'meow-mode-state-list 'special-mode)
    (meow-global-mode 1))
#+end_src

*** MacOS Bindings
#+begin_src elisp
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'none)
#+end_src

*** which key
#+begin_src elisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src
** TODO Weird Requirements
#+begin_src elisp
  (use-package el-mock
    :ensure t)
#+end_src

** Modeline Completion
#+begin_src elisp
  ;; Core completion UI
  (use-package vertico
    :init
    (vertico-mode))

  ;; Better matching (flex/fuzzy)
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))

  ;; Rich annotations in minibuffer
  (use-package marginalia
    :init
    (marginalia-mode))

  ;; Minibuffer actions (like Helm actions)
  (use-package embark
    :bind
    (("C-." . embark-act)
     ("C-;" . embark-dwim)
     ("C-h B" . embark-bindings)))

  ;; Enhanced commands (e.g. `consult-find`, `consult-buffer`, etc.)
  (use-package consult
    :bind
    (("C-s" . consult-line)
     ("C-x b" . consult-buffer)
     ("M-y" . consult-yank-pop)
     ("C-x C-r" . consult-recent-file)
     ("C-c k" . consult-ripgrep)
     ("C-c h" . consult-history)
     ("C-c m" . consult-mode-command)
     ("C-c i" . consult-imenu)))
#+end_src

* Window & File Navigation
** Default Opens
#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.pdf\\'" . doc-view-mode))
#+end_src

** Frame/Window Management
*** Perspective-el
#+begin_src elisp 
  (use-package perspective
    :custom
    (persp-mode-prefix-key (kbd "C-c M-p"))
    :init
    (persp-mode))

  (use-package persp-projectile
    :ensure t
    :after (perspective projectile))
#+end_src
** Project Management
*** Projectile
#+begin_src elisp
  (use-package projectile
    :demand t
    :bind
    (("C-c p e" . projectile-run-eshell))
    :config
    (projectile-mode +1))

  (use-package consult-projectile
    ;; :after (consult projectile)
    :demand t
    :bind
    (("C-c p p" . consult-projectile)
     ("C-c p P" . consult-projectile-switch-project)
     ("C-c p f" . consult-projectile-find-file)
     ("C-c p b" . consult-projectile-switch-to-buffer)))
#+end_src

*** envrc
#+begin_src elisp
  (use-package envrc
    ;;:after (flycheck) ; or other minor modes you want to load before envrc
    :config
    (envrc-global-mode))
#+end_src

* Editing
** Language Integrations 
*** Text
#+begin_src elisp
  (use-package ispell
   :init
   (setq ispell-dictionary "en_US")
   (setq ispell-program-name "aspell")
   (setq ispell-silently-savep t))

  (use-package flymake-aspell
    :ensure t
    :after flymake
    :hook
    ((text-mode org-mode yaml-mode markdown-mode git-commit-mode) . flymake-aspell-setup))

  (define-key minibuffer-local-map (kbd "C-v") 'yank)
#+end_src
*** Org-mode
**** Org
#+begin_src elisp
  (use-package org
   :hook (org-mode . visual-line-mode)
   :custom
   (org-startup-indented t)
   (org-log-into-drawer t)
   :config
   ;; NOTE: C-c c is already mapped, find a new keybinding for use in meow-mode
   ;; (dw/leader-key-def
   ;;  "c"  '(:which-key "Copy")
   ;;  "cl" 'org-store-link
   ;;  "ct" 'org-time-stamp-inactive
   ;;  "cj" 'org-babel-next-src-block
   ;;  "ck" 'org-babel-previous-src-block)
   )


  (use-package toc-org
    :ensure t
    :hook (org-mode . toc-org-mode))


  (use-package doct 
   :ensure t
   :commands (doct))
#+end_src

#+begin_src elisp
  (use-package org-edna
     :ensure t
     :hook
     (org-mode . org-edna-mode)
     :config
     (setq org-edna-use-inheritance t)
     (org-edna-load)
     ;; define a function to process the current Org entry for Edna properties
     (defun my/org-process-edna (&rest args)
         "Process the current Org entry for Edna properties."
      (when (org-entry-get nil "TRIGGER")
       (org-edna-process-current-entry)))
     ;; add the function to the org-trigger-hook and org-after-todo-state-change-hook
     (add-hook 'org-trigger-hook #'my/org-process-edna)
     (add-hook 'org-after-todo-state-change-hook #'my/org-process-edna))
#+end_src
**** Org-Roam
Slowly migrating away from org-roam to org-node.

***** Package Configuration
#+BEGIN_SRC elisp :noweb yes
  (use-package org-roam
    ;; :after org
    :demand t
    :config
    (org-roam-db-autosync-mode)
    (cl-defmethod org-roam-node-parent-child-title ((node org-roam-node))
      "Get the title of the parent node or an empty string if no parent is found."
      (concat (my/get-full-node-title node) "@"))

    (setq org-roam-node-display-template
        (concat "${parent-child-title:*}"
                (propertize "${tags:10}" 'face 'org-tag)))
    <<org-roam-config>>
    :custom
    (org-roam-database-connector 'sqlite-builtin))
#+END_SRC
***** Org Roam Config
:PROPERTIES:
:header-args: :tangle no :exports none :noweb-ref org-roam-config
:END:

****** Helper Functions

#+begin_src elisp
  (defun my/extract-org-id-from-link (link)
    "Extract the ID from an org-mode link."
    (when (string-match "\\[\\[id:\\(.*?\\)\\]\\[.*?\\]\\]" link)
      (match-string 1 link)))

  (defun my/org-roam-get-node-by-id (id)
    "Get an org-roam node by its ID.
  Return the node if it exists, otherwise return nil."
    (let ((node (org-roam-node-from-id id)))
      (if node
          (progn
            (message "Node Title: %s" (org-roam-node-title node))
            node)
        (progn
          (message "Node not found")
          nil))))

  (defun my/org-roam-get-node-property (node property)
    "Get a specific PROPERTY from an org-roam node by its ID.
  Return the property value if it exists, otherwise return nil."
          (let ((properties (org-roam-node-properties node)))
            (cdr (assoc property properties))))

  (defun my/org-roam-node-get-parent (node)
    (let ((parent_link (my/org-roam-get-node-property node "PARENT")))
      (if (stringp parent_link)
          (my/org-roam-get-node-by-id (my/extract-org-id-from-link parent_link))
        nil)))

  (defun my/org-roam-node-get-alias (node)
    (my/org-roam-get-node-property node "ALIAS"))

  (defun my/format-markdown-link (title protocol path)
    "Return a link valid link for Markdown based on TITLE, PROTOCOL (like http), and path."
    (concat "[" title "]" "(" protocol "://" path ")"))
#+end_src

#+begin_src elisp
  (defun my/is-child-id-p (possible-child-id parent-id)
    (let ((possible-child-node (my/org-roam-get-node-by-id possible-child-id))
          (parent-node (my/org-roam-get-node-by-id parent-id)))
      (when (and possible-child-node parent-node)
        (my/is-child-node-p possible-child-node parent-node))))

  (defun my/org-roam-nodes-equal-p (node1 node2)
    "Check if two org-roam nodes NODE1 and NODE2 are equal."
    (string= (org-roam-node-id node1)
             (org-roam-node-id node2)))

  ; TODO: Add maximum depth parameter with default
  (defun my/is-child-node-p (possible-child-node parent-node)
    "Takes two org nodes and determines if second is an ancestor of the first"
    (if (my/org-roam-nodes-equal-p possible-child-node parent-node)
        t
      (let ((direct-parent (my/org-roam-node-get-parent possible-child-node)))
        (when direct-parent
          (if (my/org-roam-nodes-equal-p direct-parent parent-node)
              t
            (my/is-child-node-p direct-parent parent-node))))))

  ;; TODO: IF IS PARENT NODE ITSELF
  (defun my/org-agenda-item-has-parent-p (item parent-id)
    "Print the :PARENT: property of the ITEM to the *Messages* buffer."
    (let ((org-parent-node (my/org-roam-get-node-by-id parent-id))
          (marker (get-text-property 0 'org-hd-marker item)))
      (when (and org-parent-node marker)
        (let ((org-node-id (org-entry-get marker "ID" t)))
          (when org-node-id
            (let ((org-node (my/org-roam-get-node-by-id org-node-id)))
              (if (my/org-roam-nodes-equal-p org-node org-parent-node)
                  t
                (my/is-child-node-p org-node org-parent-node))))))))

  (defun my/get-node-parent-hierarchy (node &optional lower-nodes)
    "Return a decending list of child nodes recursively ending with the initial NODE.
    LOWER-NODES allow prepending already calculated children and is used internal to keep state."
    (let ((nodes (cons node (or lower-nodes '()))))
      (or (when-let ((parent (my/org-roam-node-get-parent node)))
            (my/get-node-parent-hierarchy parent nodes))
          nodes)))

  (defun my/get-full-node-title (node)
    "Returns the title of the node prepended with its ancestor node titles."
    (mapconcat #'org-roam-node-title (my/get-node-parent-hierarchy node) ":"))

  (defun my/get-shorthand-node-title(node &optional accumulated-title)
    "Returns the title of the node prepended with its ancestor node titles.
  Short-circuits if an alias is found, returning the alias and the titles leading up to it."
    (let ((title (if-let* ((alias (my/org-roam-node-get-alias node)))
                     alias
                   (let ((node-title (org-roam-node-title node)))
                     (or (when-let ((parent (my/org-roam-node-get-parent node)))
                         (my/get-shorthand-node-title parent node-title))
                       node-title))))
          (previous-title (if accumulated-title
                             (concat ":" accumulated-title)
                           "")))
      (concat title previous-title)))

  (defun my/get-node-markdown-link (node)
    "Return a markdown link to the ID of a node titled with the nodes full parent path."

    (my/format-markdown-link (my/get-shorthand-node-title node) "emacs" (org-roam-node-id node)))

  (defun my/create-org-id-markdown-link (org-id)
    (let ((headline-title (get-current-headline-title)))
      (my/format-markdown-link headline-title "emacs" org-id)))
#+end_src

#+begin_src elisp
  (defun org-get-buffer-title ()
     (let* ((parsed (org-element-parse-buffer 'element))
          (title (org-element-map parsed 'keyword
                    (lambda (k)
                      (when (string-equal (org-element-property :key k) "TITLE")
                        (org-element-property :value k))))))
     (when title
       (if (interactive-p)
           (message (car title)))
       (car title))))

  (defun get-current-headline-title()
    (or (org-entry-get nil "ITEM") (car (cdr (car (org-collect-keywords '("title")))))))

  (defun gsgx/org-roam-create-note-from-headline ()
    "Create an Org-roam note from the current headline if it doesn't
  exist without jumping to it"
    (let* ((title (nth 4 (org-heading-components))))
      ;; TODO: How can I just use the title without user input?
      (node (org-roam-node-read title)))
    (if (org-roam-node-file node)
      (message "Skipping %s, node already exists" title)
      ;; Without this the subsequent kills seem to be grouped together, not
      ;; sure why
      (kill-new "")
      (org-cut-subtree)
      (org-roam-capture- :node node)
      (org-paste-subtree)
      (kill-whole-line)
      (org-capture-finalize nil)
      ;; `org-map-entries' call continue from the right place
      (setq org-map-continue-from
          (org-element-property :begin (org-element-at-point)))))

  (defun gsgx/org-roam-create-note-from-headlines ()
    (interactive)
    (if (region-active-p)
        ;; `region-start-level' means we'll map over only headlines that are at
        ;; the same level as the first headline in the region. This may or may not
        ;; be what you want
        (org-map-entries
         'gsgx/org-roam-create-note-from-headline t 'region-start-level)
      ;; If no region was selected, just create the note from the current headline
      (gsgx/org-roam-create-note-from-headline)))
#+end_src

****** User Functions

#+begin_src elisp
  (defun get-id-as-link ()
     "Retrieves the org-id of the current headline or note, formats it as a URI, and copies it to the kill-ring."
   (interactive)
   (let* ((org-id (org-id-get nil 'create))
          (node (my/org-roam-get-node-by-id org-id)))
     (if node
         (org-kill-new (my/get-node-markdown-link node))
       (org-kill-new (my/create-org-id-markdown-link org-id)))))

  (defun my/org-roam-copy-node-as-markdown-link ()
       "Prompts the user to select a node which is copied to the kill ring as a customized link."
       (interactive)
       (let* ((node (org-roam-node-read))
              (node-link (my/get-node-markdown-link node)))
         (org-kill-new node-link)))

  (defun my/org-roam-node-set-parent ()
    "Find an org-roam node and add its ID as the parent_id to the current headline."
    (interactive)
    (let* ((node (org-roam-node-read))
           (node-id (org-roam-node-id node))
           (node-title (org-roam-node-title node))
           (link (format "[[id:%s][%s]]" node-id node-title)))
      (org-entry-put (point) "PARENT" link)))

  (setq org-roam-capture-templates
        '(
          ("d" "default" plain "%?"
           :target (file+head "Inbox/Orgzly/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n") :unnarrowed t)
        ))
#+end_src

**** Org-node
Provides org-id search functionality much faster than org-roams. 

#+begin_src elisp :noweb yes
  (use-package org-node
     :after org-roam
     :config
     <<org-node-functions>>
     <<org-node-interactive>>
     (org-node-cache-mode)
     (setq org-node-alter-candidates t)
     (setq org-node-affixation-fn #'my/org-node-title-affixation-fn)
     <<org-node-hotkeys>>
     )

  (use-package org-node-fakeroam
    :after org-node
    :defer
    :config
    (setq org-roam-link-auto-replace nil)
    (setq org-roam-db-update-on-save nil)
    (org-node-fakeroam-redisplay-mode)
    (org-node-fakeroam-jit-backlinks-mode)
    ;; NOTE: roam-db needs to be updated for parent links
    (org-node-fakeroam-db-feed-mode))
#+end_src

***** KeyMaps
#+NAME: org-node-hotkeys
#+begin_src elisp :noweb yes :tangle no
  (defvar-keymap my-org-node-prefix-map
    :doc "Keymap for org-node related commands under C-n"
    "u" #'get-id-as-link
    "y" #'my/org-node-copy-node-as-markdown-link
    "f" #'org-node-find
    "p" #'my/org-node-set-parent)

  (define-key global-map (kbd "C-c n") my-org-node-prefix-map)
#+end_src

***** Utility Functions
#+NAME: org-node-functions
#+begin_src elisp :noweb rw :tangle no
  ;;; my/org-node ---

  (defun org-roam-node-to-org-node-node (node)
    (when node
      (my/org-roam-get-node-by-id (org-node-get-id node))))

  (defun my/org-node-get-node-markdown-link (node)
    "Return a markdown link to the ID of a node titled with the nodes full parent path."
    (when-let ((roam-node (org-roam-node-to-org-node-node node)))
      (my/format-markdown-link (my/get-shorthand-node-title roam-node) "emacs" (org-mem-entry-id node))))

  (defun my/org-node-get-id-as-link ()
    "Retrieves the org-id of the current headline or note, formats it as a URI, and copies it to the kll-ring."
    ((interactive))
    (let* ((org-id (org-id-get nil 'create))
           (node (org-mem-entry-by-id org-id)))
      (if node
          (org-kill-new (my/org-node-get-node-markdown-link node))
      (org-kill-new (my/create-org-id-markdown-link org-id)))))

  (defun my/org-node-title-affixation-fn (node title)
    (let ((roam-node (org-roam-node-to-org-node-node node)))
      (if roam-node
          (list (my/get-full-node-title roam-node) "" "@")
        (list title "" ""))))

  (defun my/org-node-copy-node-as-markdown-link ()
       "Prompts the user to select a node which is copied to the kill ring as a customized link."
       (interactive)
       (let* ((node (org-roam-node-to-org-node-node (org-node-read)))
              (node-link (my/get-node-markdown-link node)))
         (org-kill-new node-link)))
#+end_src

***** Interactive Functions
#+NAME: org-node-interactive
#+begin_src elisp
  (defun my/org-node-set-parent ()
    "Find an org-node and add its ID as the parent_id to the current headline."
    (interactive)
    (let* ((node (org-node-read))
           (node-id (org-node-get-id node))
           (node-title (org-node-get-title node))
           (link (format "[[id:%s][%s]]" node-id node-title)))
      (org-entry-put (point) "PARENT" link)))

#+end_src

**** Org-Agenda
***** Org-Super-Agenda

#+begin_src elisp :noweb-ref org-super-agenda-defun :tangle no
  (setq org-agenda-remove-file-column t)
  (setq org-super-agenda-header-prefix "ðŸ“Œ ")
  (setq org-agenda-prefix-format
        '((agenda . " %?-12t% s")
          (todo . " %e ")
          (tags . " %-12:c")
          (search . " %-12:c")))

#+end_src

#+begin_src elisp :noweb yes
  (use-package org-super-agenda
    :ensure t
    :after org-roam
    :config
    (org-super-agenda-mode 1)
    <<org-super-agenda-defun>>)
#+end_src
**** Org-bullets 
#+begin_src elisp
  (use-package org-bullets
    :ensure t
    :hook (org-mode . org-bullets-mode)
    :config
    (setq org-bullets-bullet-list '("â—‰" "â—‹" "âœ¸" "âœ¿" "â–¶"))
    (setq org-ellipsis "â¤µ")
    (setq org-hide-leading-stars t))
#+end_src
**** ox-hugo
#+begin_src elisp
  (use-package ox-hugo
    :ensure t
    :pin melpa
    :after ox)
#+end_src
**** Auto Tangle
#+begin_src elisp
  (use-package org-auto-tangle
    :hook (org-mode . org-auto-tangle-mode))
#+end_src
**** TODO nowebdit
:PROPERTIES:
:ID:       68B8966D-3EE7-48FE-B83F-52A8F224602D
:PARENT:   [[id:6cacb474-009b-491c-a8fb-cb8b1121e47d][MineMacs]]
:END:

#+begin_src elisp
  (require 'org-src)
  (require 'dash)
  (defun my/org-src-edit-in-buffer (block-name handler)
    "Edit the named src-block in the background, apply changes, and kill the edit buffer."
    (save-excursion
      ;; Jump to the block
      (when (org-babel-goto-named-src-block block-name)
        (user-error "No source block found with name: %s" block-name))
      (let* ((element (org-element-context))
             (type (org-element-type element)))
        (unless (eq type 'src-block)
          (user-error "The element at point is not a src-block"))
        (let ((edit-buf-name (format "*my-org-src-edit: %s*" block-name)))
          ;; Override org-src-switch-to-buffer so it just `set-buffer`
          ;; instead of showing in a window.
          (cl-letf (((symbol-function 'org-src-switch-to-buffer)
                     (lambda (buffer &optional _return-to-window)
                       (set-buffer buffer))))   ;; <-- no window switch
            (org-src--edit-element
             element
             edit-buf-name
             (lambda ()
               ;; The "initialize" function: choose major-mode for the block
               (let ((lang (org-element-property :language element)))
                 (if-let ((mode (cdr (assoc lang org-src-lang-modes))))
                     (funcall mode)
                   (fundamental-mode))))
             t     ;; WRITE-BACK: non-nil => buffer contents will replace the block.
             nil   ;; CONTENTS: nil => use org-src--contents-area
             nil)) ;; REMOTE: nil => let Org attempt to preserve point/mark

          ;; At this point, `org-src--edit-element` has created and populated
          ;; the edit buffer, but we never actually displayed it.

          (with-current-buffer edit-buf-name
            (condition-case err
                (funcall handler)
              (error
               (org-edit-src-abort)
               (signal (car err) (cdr err))))
            (org-edit-src-exit))))))
#+end_src

#+begin_src elisp
  (defun my/org-src-set-content-via-backgroud-edit-buffer (src-name new-content)
    (my/org-src-edit-in-buffer src-name
                               (lambda ()
                                 (delete-region (point-min) (point-max))
                                 (insert (or new-content "")))))
#+end_src

#+begin_src elisp
  (defun my/org-get-src-block (name &optional buffer)
    (when name
      (with-current-buffer (or buffer (current-buffer))
        (let ((block (org-babel-lob--src-info name)))
          (if block
              block
            (progn
              (message "Could not find block with name %s" name)
              nil))))))

  (defun my/org-get-src-content (name &optional buffer)
    "Get the content of the current Org source block (optionally in BUFFER) with indentation removed."
    (when-let ((block (my/org-get-src-block name buffer)))
      (message "Block: \n%S" block)
      (or (nth 1 block) "")))
      ;; NOTE: was using this, but it doesn't seem to include noweb blocks
      ;; (org-babel-expand-noweb-references block)))

  (defun my/org-get-src-header (name key &optional buffer)
    (when (and name key)
      (cdr (assoc key (nth 2 (my/org-get-src-block name buffer))))))

  ;; (defun set-src-content (name new-content &optional buffer)
  ;;   "Replace the content of the src-block with NAME with NEW-CONTENT."
  ;;   (message "SETTING %s to: \n%s" name new-content)
  ;;   (with-current-buffer (or buffer (current-buffer))
  ;;     (message "SETTING content in %s" (buffer-name))
  ;;     (save-excursion
  ;;       (when (org-babel-goto-named-src-block name)
  ;;         (let* ((element (org-element-at-point))
  ;;                (begin (save-excursion
  ;;                         (re-search-forward "^[ \t]*#\\+begin_src.*\n" nil t)
  ;;                         (point)))
  ;;                (end (org-element-property :end element)))
  ;;           (delete-region begin (1- end))  ;; Remove old content
  ;;           (insert new-content "\n"))))))   ;; Insert new content

  (defun set-org-src-block-content (block-name new-content &optional buffer)
    "Replace the contents of the org-mode src block named BLOCK-NAME with NEW-CONTENT.
  If BUFFER is provided, operate on that buffer; otherwise, use the current buffer.
  This function always ensures there is a newline immediately before the #+end_src marker."
    (with-current-buffer (or buffer (current-buffer))
      (save-excursion
        ;; Jump to the named src block (this moves point to the #+NAME: line).
        (org-babel-goto-named-src-block block-name)
        ;; Search forward for the beginning marker.
        (if (re-search-forward "^[ \t]*#\\+begin_src\\b" nil t)
            (let ((content-start (progn
                                   (forward-line 1)
                                   (point))))
              ;; Now search for the end marker.
              (if (re-search-forward "^[ \t]*#\\+end_src\\b" nil t)
                  (let ((content-end (progn
                                       (end-of-line 0)
                                       (point))))
                    (goto-char content-start)
                    (delete-region content-start content-end)
                    (insert new-content)
                    ;; Ensure there's a newline before the #+end_src marker.
                    )
                (message "Could not find the end of the src block for '%s'" block-name)))
          (message "Could not find the beginning of the src block for '%s'" block-name)))))

  (defun my-org-update-src-block (new-content)
    "Replace the content of the current Org-mode src block with NEW-CONTENT."
    (let* ((element (org-element-at-point)))
      (when (eq (org-element-type element) 'src-block)
        (let* ((begin (org-element-property :begin element))
               (end (org-element-property :end element)))
          (save-excursion
            (goto-char begin)
            (re-search-forward "^[ \t]*#\\+begin_src.*\n") ;; Move to the content start
            (let ((content-start (point)))
              (goto-char end)
              (re-search-backward "^[ \t]*#\\+end_src" nil t)
              (delete-region content-start (point)) ;; Clear old content
              (insert (concat new-content "\n\n") "\n") ;; Insert new content
              ))))))
#+end_src

#+begin_src elisp
  (defun my/replace-text-at (text beg end new-text)
    (concat (substring text 0 beg)
            new-match-text
            (substring text end)))

  (defun append-newline-if-nonempty (str)
    (if (and str (not (string-empty-p str))) 
        (concat str "\n") 
      str))

  (defun my/expand-noweb (text origin-buffer &optional already-expanded-names match-start)
    "Expand all Noweb references in TEXT by retrieving them from ORIGIN-BUFFER.
  Returns the expanded string. Recursively expands references inside the inserted blocks."
    ;;(message "Inputtext: \n%s" text)
    ;; TODO: Matches all noweb syntax but only ^ is supported
    (if (string-match (org-babel-noweb-wrap) text match-start)
        ;; TODO: if these checks fail, probably throw 
        (-when-let* ((src-name (match-string 1 text))
                     (new-match-start (match-beginning 0))
                     (new-match-end (match-end 0)))
          (let ((src-content (my/org-get-src-content src-name origin-buffer)))
            (if (or (not src-content)
                    (memq src-name already-expanded-names)
                    (not (string= "rw" 
                                  (my/org-get-src-header src-name :noweb origin-buffer))))
                (my/expand-noweb text origin-buffer already-expanded-names new-match-end)
              (let* ((expanded-src-content (my/expand-noweb
                                            src-content
                                            origin-buffer
                                            (append already-expanded-names (list src-name))))
                     (new-match-text (concat "#+SRC_BEGIN_" src-name "\n"
                                             (append-newline-if-nonempty expanded-src-content)
                                             "#+SRC_END_" src-name))
                     (new-text (my/replace-text-at text new-match-start new-match-end new-match-text)))
                (my/expand-noweb
                 new-text
                 origin-buffer
                 (append already-expanded-names (list src-name))
                 new-match-start)))))
      text))


  (defun my-search-noweb-references (origin-buffer)
    "Search for Noweb references in the current buffer and replace them with expanded content from ORIGIN-BUFFER."
    (save-excursion
      (goto-char (point-min))
      ;; Grab the entire buffer as a string.
      (let ((original-text (buffer-substring-no-properties (point-min) (point-max))))
        ;; Expand the text using the helper function.
        (let ((expanded-text (my/expand-noweb original-text origin-buffer)))
          ;; Replace the current buffer contents with the expanded text.
          (delete-region (point-min) (point-max))
          (insert expanded-text)))))
#+end_src

#+begin_src elisp :noweb no
  (defun my/src-comment-begin-regex (&optional src-name)
    (if src-name
        (concat "^[ \t]*#\\+SRC_BEGIN_" (regexp-quote src-name) ".*\n")
      "^[ \t]*#\\+SRC_BEGIN_\\([^ \n]+\\).*\n"))

  ;; TODO: should this start with \n? seems to work better if i don't check, but it should always have a newline before it...
  (defun my/src-comment-end-regex (&optional src-name)
    (if src-name
        (concat "[ \t]*#\\+SRC_END_" (regexp-quote src-name))
      "[ \t]*#\\+SRC_END_\\([^ \n]+\\)"))


  (defun my/parse-src-blocks (text &optional existing-children)
    "Internal helper returning a cons (BLOCKS . REPLACED-TEXT).
  BLOCKS is a list of block structures.
  REPLACED-TEXT is TEXT with recognized blocks replaced by <<NAME>>."
    (if (string-match (my/src-comment-begin-regex) text)
        (let* ((begin-pos   (match-beginning 0))
               (after-begin (match-end 0))
               (block-name  (match-string 1 text)))
          (if (string-match (my/src-comment-end-regex block-name) text after-begin)
              (progn
                (let* ((end-pos   (match-beginning 0))
                       (after-end (match-end 0))
                       (body (substring text after-begin end-pos))
                       (replaced-text
                        (concat (substring text 0 begin-pos)
                                "<<" block-name ">>"
                                (substring text after-end)))
                       (child-comment (my/parse-src-blocks body)))
                  (my/parse-src-blocks replaced-text (append
                                                      existing-children
                                                      (list
                                                       (list :name block-name
                                                             :content (plist-get child-comment :content)
                                                             :children (plist-get child-comment :children)))))))
            (progn
              (list :name nil ;; NOTE: nil because block was incomplete
                    :content text
                    :children existing-children))))
      (progn
       (list :name nil
            :content text
            :children existing-children))))
#+end_src

#+begin_src elisp
  (defun my/get-org-src-edit-origin-buffer ()
    "When in a org-src-edit buffer, return its src-block origin buffer if it exists."
    (-when-let* ((marker org-src--beg-marker)
                 (buf (marker-buffer marker)))
      buf))

  (defun my/get-src-block-info-from-edit-buffer ()
    (when-let ((src-block-marker org-src--beg-marker)
               (source-buffer (my/get-org-src-edit-origin-buffer)))
      (with-current-buffer source-buffer
        (goto-char src-block-marker)
        (org-babel-get-src-block-info))))

  (defun my/get-org-src-edit-header-arg (key)
    ;; (message "Current buffer vars: %s" (buffer-local-variables))
    (-if-let* ((babel-info (my/get-src-block-info-from-edit-buffer))
               (header-alist (nth 2 babel-info))
               (header-alist-item (assoc key header-alist))
               (header-arg-value (cdr header-alist-item)))
        header-arg-value
      (message (concat "Could not find babel info in " (buffer-name)))))

  (defun my/is-no-web-read-write ()
    (when-let ((noweb-value (my/get-org-src-edit-header-arg :noweb)))
      (string= noweb-value "rw")))

  (defun my-org-src-edit-setup ()
    "Replace all occurrences of 'foo' with 'foo' when the Org Src buffer opens."
    (when (my/is-no-web-read-write)
      (my-search-noweb-references (my/get-org-src-edit-origin-buffer))))

  (add-hook 'org-src-mode-hook #'my-org-src-edit-setup)

  (defun my/loop-children (children)
      (dolist (child children)
        (my/org-src-set-content-via-backgroud-edit-buffer (plist-get child :name) (plist-get child :content))
        (when-let ((subchildren (plist-get child :children)))
            (my/loop-children subchildren))))

  (defun my/compress-noweb-references ()
    "Search for Noweb references in the current buffer and replace them with expanded content from ORIGIN-BUFFER."
    (save-excursion
      (goto-char (point-min))
      ;; Grab the entire buffer as a string.
      (let ((original-text (buffer-substring-no-properties (point-min) (point-max))))
        ;; Expand the text using the helper function.
        (let ((src-comment (my/parse-src-blocks original-text)))
          ;; Replace the current buffer contents with the expanded text.
          (delete-region (point-min) (point-max))
          (with-current-buffer (my/get-org-src-edit-origin-buffer)
            (my/loop-children (plist-get src-comment :children)))
          (insert (plist-get src-comment :content))))))

  (defun my-org-src-exit-advice (&optional save)
    "Replace all occurrences of 'foo' back to 'foo' before returning to the Org buffer."
    (message "ARGS: %S" org-src--allow-write-back)
    (when (and
           org-src--allow-write-back
           (my/is-no-web-read-write))
      (my/compress-noweb-references)))

  ;;(advice-add 'org-edit-src-save :before #'my-org-src-save-advice)
  ;;(advice-remove 'org-edit-src-save  #'my-org-src-save-advice)



  ;; TODO: this hok runs even if abort is ran... how cna I tell?
  (advice-add 'org-edit-src-exit :before #'my-org-src-exit-advice)
  ;;(advice-remove 'org-edit-src-exit #'my-org-src-exit-advice)
#+end_src

#+begin_src elisp
  ;; TODO: Finish

  ;; TODO: This one I don't recall is for ob-ts-node
  ;; (org-babel-do-load-languages
  ;;  'org-babel-load-languages
  ;;  '((typescript . t))) ;; Enable TypeScript

  ;; (setq org-babel-typescript-command "npx -p ts-node -- ts-node")

  ;; (use-package quelpa
  ;;   :ensure t)

  ;; (use-package ob-ts-node
  ;;   :quelpa
  ;;   (ob-ts-node :repo "tmythicator/ob-ts-node"
  ;;               :fetcher github))

  ;; (quelpa '(ob-ts-node :repo "tmythicator/ob-ts-node" :fetcher github))

  ;; (org-babel-do-load-languages
  ;;  'org-babel-load-languages
  ;;  '((ts-node . t)
  ;;    ))
#+end_src

*** LSP-mode
#+begin_src elisp
  (use-package lsp-mode
    :defer t
    :hook ((js2-mode typescript-mode) . lsp)
    :commands (lsp lsp-deferred)
    :config
    (defvar my/lsp-command-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "d") #'xref-find-definitions)
        (define-key map (kbd "r") #'xref-find-references)
        (define-key map (kbd "R") #'lsp-rename)
        (define-key map (kbd "a") #'lsp-execute-code-action)
        (define-key map (kbd "f") #'lsp-format-buffer)
        (define-key map (kbd "s") #'consult-lsp-symbols)
        (define-key map (kbd "e") #'lsp-treemacs-errors-list)
        (define-key map (kbd "i") #'lsp-find-implementation)
        (define-key map (kbd "t") #'lsp-find-type-definition)
        (define-key map (kbd "h") #'lsp-ui-doc-show)
        map)
      "My custom LSP command keymap.")
    (global-set-key (kbd "C-c l") my/lsp-command-map))


  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-hover nil)
    (lsp-ui-doc-position 'bottom)
    :config
    (lsp-ui-doc-show))

  (use-package dap-mode
    :after dap-node
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)
    )

  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind (:map company-active-map
           ("<tab>" . company-complete-selection))
          (:map lsp-mode-map
           ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

  (use-package company-box
    :hook (company-mode . company-box-mode))

  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode)
    :hook (lsp-mode . flycheck-mode)
    :config
    (setq flycheck-check-syntax-automatically '(mode-enabled save)))
#+end_src
*** Python
#+begin_src elisp
  (use-package python-mode
    :hook ((python-mode . lsp-deferred)
           (python-mode . (lambda ()
                            (setq comment-style 'plain)
                            (setq indent-tabs-mode nil)
                            (setq tab-width 4))))
    :custom
    (dap-python-debugger 'debugpy)
    :config
    (require 'dap-python))

  (use-package python-mode
    :hook (python-mode . lsp-deferred)
    :custom
    (dap-python-debugger 'debugpy)
    :config
    (require 'dap-python))

  (use-package lsp-pyright
    :after lsp-mode
    :hook (python-mode . (lambda ()
                           (require 'lsp-pyright)
                           (lsp-deferred))))

  (use-package pyvenv
    :config
    (pyvenv-mode 1))
#+end_src
*** Clojure(Script) 
#+begin_src elisp
  (use-package cider
    :ensure t
    :mode "\\.clj[sc]?\\'"
    :config
    (evil-collection-cider-setup))

#+end_src
*** JavaScript/TypeScript
#+begin_src elisp
  (defun dw/set-js-indentation ()
  (setq js-indent-level 2)
  (setq display-line-numbers 'relative)
  (setq evil-shift-width js-indent-level)
  (setq-default tab-width 2))

  (use-package typescript-mode
    :hook (typescript-mode . lsp-deferred)
    :mode "\\.ts\\'"
    :config
    (setq typescript-indent-level 2))

  (use-package js2-mode
    :hook (js2-mode . lsp-deferred)
    :mode (("\\.js\\'" . js2-mode)
           ("\\.cjs\\'" . js2-mode)
           ("\\.mjs\\'" . js2-mode))
    :config
    (add-to-list 'magic-mode-alist '("#!/usr/bin/env node" . js2-mode))
    ;; Don't use built-in syntax checking
    (setq js2-mode-show-strict-warnings nil)
    (add-hook 'js2-mode-hook #'dw/set-js-indentation)
    (add-hook 'json-mode-hook #'dw/set-js-indentation))

  (use-package rjsx-mode
    :ensure t
    :mode (("\\.jsx\\'" . rjsx-mode))
    :config
    (add-hook 'rjsx-mode-hook #'dw/set-js-indentation))

  ;; (use-package indium
  ;;     :ensure t
  ;;     :hook ((js2-mode . indium-interaction-mode)))



  ;; (cl-defmethod project-root ((project (head eglot-project)))
  ;;   (cdr project))

  ;; (defun my-project-try-tsconfig-json (dir)
  ;;   (when-let* ((found (locate-dominating-file dir "tsconfig.json")))
  ;;     (cons 'eglot-project found)))

  ;; (add-hook 'project-find-functions
  ;;           'my-project-try-tsconfig-json nil nil)

  ;; (add-to-list 'eglot-server-programs
  ;;              '((typescript-mode js2-mode) "typescript-language-server" "--stdio"))

#+end_src
*** Rust
add package runtfmt

#+begin_src elisp
  (use-package rust-mode
     :ensure t
     :mode "\\.rs\\'"
     :config
     (setq rust-format-on-save t)
     (add-hook 'rust-mode-hook #'lsp))
#+end_src

*** Dockerfile
#+begin_src elisp 
  (use-package dockerfile-mode
     :ensure t
     :mode (("Dockerfile\\'" . dockerfile-mode)))
#+end_src
*** Markdown
#+begin_src elisp
  (use-package markdown-mode
     :ensure t
     :mode (("README\\.md\\'" . gfm-mode)
            ("\\.md\\'" . markdown-mode)
            ("\\.markdown\\'" . markdown-mode))
     :init (setq markdown-command "pandoc"))
#+end_src
*** JSON
#+begin_src elisp
  (use-package json-mode
     :ensure t)
#+end_src
*** YAML
#+begin_src elisp
  (use-package yaml-mode
    :ensure t
    :mode "\\.yml\\'")
#+end_src
*** Common Lisp
#+begin_src elisp
  (use-package slime
    :ensure t
    :defer t
    :config
    (setq inferior-lisp-program "sbcl")) 
#+end_src
** Automatic Formatting
#+begin_src elisp
  (use-package apheleia
    :config
    (setf (alist-get 'prettier apheleia-formatters)
          `("prettier" "--stdin" "--stdin-filepath" ,(lambda () buffer-file-name)))
    (setf (alist-get 'web-mode apheleia-mode-alist) 'prettier)
    (setf (alist-get 'typescript-mode apheleia-mode-alist) 'prettier)
    (setf (alist-get 'js-mode apheleia-mode-alist) 'prettier)
    (setf (alist-get 'js2-mode apheleia-mode-alist) 'prettier)
    (apheleia-global-mode +1))
#+end_src

** Helpful Minor Modes
*** Prog-mode
#+begin_src elisp
  (use-package hideshow
     :ensure t
     :hook (prog-mode . hs-minor-mode))
#+end_src

*** LISP Navigation
#+begin_src elisp
  ;; (use-package lispy
  ;;   :ensure t
  ;;   :hook ((emacs-lisp-mode . lispy-mode)
  ;;          (scheme-mode . lispy-mode)
  ;;          (clojure-mode . lispy-mode)
  ;;          (clojurescript-mode . lispy-mode)))

  ;; (use-package lispyville
  ;;   :ensure t
  ;;   :hook ((lispy-mode . lispyville-mode))
  ;;   :config
  ;;   (lispyville-set-key-theme '(operators c-w additional)))

  (use-package paredit
    :ensure t)
#+end_src

*** hl-todo
#+begin_src elisp
  (use-package hl-todo
    :ensure t
    :defer t
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF0000")
            ("FIXME"  . "#FF4500")
            ("DEBUG"  . "#1E90FF")
            ("NOTE"   . "#FFFF00")
            ("GOTCHA" . "#FFD700")))
    (setq hl-todo-include-modes '(prog-mode)))
#+end_src

*** Yasnippet
#+begin_src elisp
  (use-package yasnippet
    :ensure t
    :hook ((prog-mode . yas-minor-mode)
           (org-mode . yas-minor-mode))
    :config
    (yas-reload-all))

  (use-package yasnippet-snippets
    :ensure t)

  (defun my/autoinsert-yas-expand()
    "Replace text in yasnippet template."
    (yas/expand-snippet (buffer-string) (point-min) (point-max)))
#+end_src

*** avy
#+begin_src elisp
  (use-package avy
    :ensure t
    :config
    (dw/leader-key-def
      "s" #'avy-goto-char)
    (setq avy-background t
          avy-style 'at-full))

#+end_src

*** Rainbow Delimiters
Colorize nested parens & brackets for ease in programming modes.

#+begin_src elisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src


*** Flyover
#+begin_src elisp
  (use-package flyover
    :after flycheck
    :hook (flycheck-mode . flyover-mode)
    :custom
    (flyover-levels '(error warning info))

    (flyover-use-theme-colors t)
    (flyover-background-lightness 45)
    (flyover-percent-darker 40)
    (flyover-text-tint 'lighter)
    (flyover-text-tint-percent 50)

    :config
    (custom-set-faces
     '(flyover-error
       ((t :background "#453246"
           :foreground "#ea8faa"
           :height 0.9
           :weight normal)))
     '(flyover-warning
       ((t :background "#331100"
           :foreground "#DCA561"
           :height 0.9
           :weight normal)))
     '(flyover-info
       ((t :background "#374243"
           :foreground "#a8e3a9"
           :height 0.9
           :weight normal)))))
#+end_src

* Applications
** Notmuch
#+begin_src elisp
  (use-package notmuch
    :ensure t
    :commands (notmuch notmuch-search notmuch-tree)
    :init
    (setq mail-user-agent 'notmuch-user-agent)
    :custom
    (notmuch-fcc-dirs nil)
    (notmuch-search-oldest-first nil)
    (notmuch-show-all-tags-list t)
    (notmuch-show-inline-images t))
#+end_src

*** Some Old Custom Fn
#+begin_src elisp
  (org-link-set-parameters "notmuch"
      :follow 'org-notmuch-open
      :store 'org-notmuch-store-link)

  (defun org-notmuch-open (id)
   "Visit the notmuch message or thread with id ID."
   (notmuch-show id))

  ;; FIXME: Console complains about quotes here
  (defun org-notmuch-store-link ()
     "Store a link to a notmuch mail message."
     (cl-case major-mode
         ('notmuch-show-mode
          ;; Store link to the current message
          (let* ((id (notmuch-show-get-message-id))
                 (link (concat "notmuch:" id))
                 (description (format "Mail: %s" (notmuch-show-get-subject))))
              (org-store-link-props
               :type "notmuch"
               :link link
               :description description)))
         ('notmuch-search-mode
       ;; Store link to the thread on the current line
       (let* ((id (notmuch-search-find-thread-id))
              (link (concat "notmuch:" id))
              (description (format "Mail: %s" (notmuch-search-find-subject))))
           (org-store-link-props
            :type "notmuch"
            :link link
            :description description)))))
#+end_src
** Elfeed
#+begin_src elisp
  (use-package elfeed
      :ensure t
      :config
      (setq-default elfeed-search-filter "@6-months-ago +unread -music")
      (elfeed-set-max-connections 4)
      (setq elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory)
              elfeed-show-entry-switch 'display-buffer))

  (use-package elfeed-org
      :ensure t
      :config
      (elfeed-org))

  (use-package mpv
    :ensure t)

  (require 'elfeed)
  (require 'mpv)

  (defun elfeed-mpv-start (&optional use-generic-p)
    "Youtube Link"
    (interactive "P")
    (let ((entries (elfeed-search-selected)))
      (cl-loop for entry in entries
               do (elfeed-untag entry 'unread)
               when (elfeed-entry-link entry)
               do (mpv-start it))
      (mapc #'elfeed-search-update-entry entries)
      (unless (use-region-p) (forward-line))))


  (with-eval-after-load "elfeed-search"
  (define-key elfeed-show-mode-map (kbd "C-c C-p") 'elfeed-mpv-start)
  (define-key elfeed-search-mode-map (kbd "C-c C-p") 'elfeed-mpv-start))

  ;; TODO: Change keybindings to use leader
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c SPC SPC") 'mpv-pause)
    (define-key org-mode-map (kbd "C-c SPC x") 'mpv-kill)
    (define-key org-mode-map (kbd "C-c SPC l") 'mpv-seek-forward)
    (define-key org-mode-map (kbd "C-c SPC h") 'mpv-seek-backward)
    (define-key org-mode-map (kbd "C-c SPC k") 'mpv-speed-increase)
    (define-key org-mode-map (kbd "C-c SPC j") 'mpv-speed-decrease)
    (define-key org-mode-map (kbd "C-c SPC K") 'mpv-volume-increase)
    (define-key org-mode-map (kbd "C-c SPC J") 'mpv-volume-decrease)
    (define-key org-mode-map (kbd "C-c SPC c") 'mpv-insert-playback-position)
    (define-key org-mode-map (kbd "C-c SPC C") 'mpv-seek-to-position-at-point)
    ;;(define-key org-mode-map (kbd "C-c C-. ") 'mpv-playlist-next)
    ;;(define-key org-mode-map (kbd "C-c C-. ") 'mpv-playlist-prev)
  )
#+end_src

** Terminal Emulators
*** vTerm
#+begin_src elisp
  (use-package vterm
  :ensure t)
#+end_src
** Magit (git client)

#+begin_src elisp
  (use-package magit
    :ensure t
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    :bind (("C-c p g" . magit-status))
    :bind (:map magit-status-mode-map
                ("x"   . magit-discard)
                ("v" . meow-line)))

  (use-package magit-todos
    :ensure t
    :defer t
    :hook (magit-mode . magit-todos-mode))

  (use-package orgit
    :ensure t)
#+end_src

* Utility 
** Cache Files
Get cache files outta my project tree!

#+begin_src elisp
(setq backup-directory-alist
`(("." . ,(concat user-emacs-directory "backups"))))
#+end_src

** pyenv
#+begin_src elisp
  (use-package pyvenv
    :ensure t)
#+end_src

#+RESULTS:
** Relative Line Number Quick Toggle
#+begin_src elisp
(defun toggle-relative-line-numbers ()
(interactive)
(if (eq display-line-numbers 'visual)
(setq display-line-numbers t)
(setq display-line-numbers 'visual)))
#+end_src
** Tmux Integration
#+begin_src elisp
  ;;https://www.reddit.com/r/emacs/comments/xyo2fo/orgmode_vterm_tmux/
  (use-package ob-tmux
  ;; Install package automatically (optional)
  :ensure t
  :custom
  (org-babel-default-header-args:tmux
  '((:results . "silent")	;
  (:session . "default")	; The default tmux session to send code to
  (:socket  . nil)))		; The default tmux socket to communicate with
  ;; The tmux sessions are prefixed with the following string.
  ;; You can customize this if you like.
  (org-babel-tmux-session-prefix "ob-")
  ;; The terminal that will be used.
  ;; You can also customize the options passed to the terminal.
  ;; The default terminal is "gnome-terminal" with options "--".
  (org-babel-tmux-terminal "kitty")
  (org-babel-tmux-terminal-opts '("-T" "ob-tmux" "-e")))
#+end_src

** org-mime
#+begin_src elisp
  (use-package org-mime
    :config
    (setq org-mime-export-options '(:section-numbers nil
                                    :with-author nil
                                    :with-toc nil)))
#+end_src
* Misc. 
** Load Custom.el
#+begin_src elisp
  (setq custom-file (expand-file-name "custom.el"
                      user-emacs-directory))

  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

** Theme
Load after custom.el so it remembers your confirmation to load the the theme. 

#+begin_src elisp :noweb-ref emacs-theme
  (use-package modus-themes
   :ensure t
   :config
   (setq modus-themes-org-blocks 'grey-background
         modus-themes-bold-constructs nil)
   (setq modus-themes-common-palette-overrides
         modus-themes-preset-overrides-intense)
   (load-theme 'modus-vivendi)
   (define-key global-map (kbd "<f5>") #'modus-themes-toggle))
#+end_src

** TODO Misc
#+begin_src elisp
  (use-package hyperbole
     :ensure t
     :config
     ;; Set the location of the Hyperbole Info files
     (setq Info-default-directory-list
           (cons (expand-file-name "info" user-emacs-directory)
                  Info-default-directory-list)))

  (defun send-to-eshell-remote (command)
   (let ((buf (get-buffer-create "eshell-remote")))
    (with-current-buffer buf
     (unless (eq major-mode 'eshell-mode)
      (eshell-mode))
     (goto-char (point-max))
     (insert command)
     (eshell-send-input))))
#+end_src

#+begin_src elisp
  (use-package gptel
    :ensure t)
#+end_src

* Meta
** Setup
*** Dependancies
**** cmake
:PROPERTIES:
:arch_package: cmake
:version:  latest
:END:
vterm needs CMake to be compiled
**** make
:PROPERTIES:
:arch_package: make 
:version:  latest
:END:
And cmake appears to require make

